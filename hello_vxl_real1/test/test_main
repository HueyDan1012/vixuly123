#include <avr/io.h>
#include <avr/interrupt.h>
#include <util/delay.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

// --- INCLUDE DRIVERS ---
#include "i2c.h"
#include "mpu6050.h"
#include "dc_motor.h"
#include "filter.h"
#include "pid.h"

// =============================================================
//                CẤU HÌNH (TUNING PARAMETERS)
// =============================================================

// 1. OFFSET GYRO (QUAN TRỌNG: ĐIỀN SỐ BẠN ĐO ĐƯỢC VÀO ĐÂY)
// Nếu chưa đo, hãy để tạm là 0 hoặc -245 (ví dụ)
#define GYRO_OFFSET_HARDCODE  -245 

// 2. PID PARAMETERS (Đã nhân 1000)
// Ví dụ: Kp = 18.0 -> 18000
#define KP_VAL          20000L 
#define KI_VAL          80L    
#define KD_VAL          1200L  

// 3. GÓC MỤC TIÊU
#define TARGET_ANGLE    0      

// =============================================================
//                     BIẾN TOÀN CỤC
// =============================================================
volatile uint8_t sys_tick_flag = 0; // Cờ báo hiệu chạy Loop
volatile uint8_t timer_counter = 0; // Biến đếm trong ngắt

MPU6050_t mpu;
CompFilter_t angle_filter;
PID_Config_t balance_pid;

// =============================================================
//                     DRIVER SETUP
// =============================================================

// --- UART DEBUG ---
void UART_Init(void) {
    UBRR0H = 0; UBRR0L = 103; // 9600 baud
    UCSR0B = (1 << RXEN0) | (1 << TXEN0);
    UCSR0C = (1 << UCSZ01) | (1 << UCSZ00);
}
void UART_Print(char *str) {
    while(*str) { while(!(UCSR0A & (1<<UDRE0))); UDR0 = *str++; }
}

// --- HÀM IN DEBUG (Góc & PWM) ---
// Chỉ in mỗi 100ms để không làm chậm robot
void Print_Debug(int32_t angle, int16_t pwm) {
    static uint8_t count = 0;
    count++;
    if (count >= 10) { 
        count = 0;
        char buf[32];
        // In ra: Angle (độ) | PWM
        sprintf(buf, "A:%ld | P:%d\r\n", angle/1000, pwm);
        UART_Print(buf);
        
       
    }
}

// --- TIMER0 INIT (100Hz) ---
void Timer0_Init(void) {
    TCCR0A = 0;
    TCCR0B = (1 << CS01) | (1 << CS00); // Prescaler 64 -> 1ms overflow
    TCNT0 = 0;
    TIMSK0 |= (1 << TOIE0);
}

// --- TIMER0 ISR ---
ISR(TIMER0_OVF_vect) {
    timer_counter++;
    // 1ms * 10 = 10ms
    if (timer_counter >= 10) {
        timer_counter = 0;
        sys_tick_flag = 1; // Bật cờ, đánh thức Main Loop
    }
}

// =============================================================
//                        MAIN PROGRAM
// =============================================================
int main(void) {
    // 1. Setup Hardware
    DDRB |= (1 << PB5); // LED Debug
    UART_Init();
    MPU6050_Init();
    Motor_Init();
    

    // 2. Setup Middleware
    CompFilter_Init(&angle_filter, 980); // Tin Gyro 98%
    PID_Init(&balance_pid, KP_VAL, KI_VAL, KD_VAL, 255); // Max PWM 255

    // Bật đèn báo hiệu đã Init xong
    PORTB |= (1 << PB5);
    _delay_ms(500);
    PORTB &= ~(1 << PB5);

    // 3. Start System
    Timer0_Init();
    sei(); // Bật ngắt toàn cục

    while (1) {
        // Chờ Timer báo hiệu (đúng mỗi 10ms)
        if (sys_tick_flag == 1) {
            sys_tick_flag = 0; // Xóa cờ ngay

            // --- A. ĐỌC CẢM BIẾN ---
            MPU6050_Read_All(&mpu);

            // --- B. XỬ LÝ SỐ LIỆU ---
            // Tính góc Accel (dùng float tạm thời để chính xác)
            float acc_angle_f = atan2((float)mpu.Accel_Y_RAW, (float)mpu.Accel_Z_RAW) * 57.296f;
            int32_t acc_angle_int = (int32_t)(acc_angle_f * 1000);

            // Tính Gyro Rate (Trừ Offset cứng -> Scale)
            int32_t gyro_val = mpu.Gyro_X_RAW - GYRO_OFFSET_HARDCODE;
            int32_t gyro_rate_int = (gyro_val * 15267L) / 1000;

            // --- C. BỘ LỌC (FILTER) ---
            // Input: Accel & Gyro | Output: Current Angle
            int32_t current_angle = CompFilter_Update(&angle_filter, acc_angle_int, gyro_rate_int, 10);

            // --- D. PID COMPUTE ---
            // Input: Current Angle & Target (0) | Output: PWM (-255 đến 255)
            int16_t pid_output = PID_Compute(&balance_pid, current_angle, TARGET_ANGLE * 1000);

            // --- E. MOTOR CONTROL ---
            // Chạy thẳng vào Motor (Bỏ qua kiểm tra góc an toàn theo yêu cầu)
            Motor_L_Control(pid_output);
            Motor_R_Control(pid_output);

            // --- F. DEBUG ---
            Print_Debug(current_angle, pid_output);
        }
    }
}

